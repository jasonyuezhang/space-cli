package vite

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/happy-sdk/space-cli/internal/dns"
	"github.com/happy-sdk/space-cli/pkg/config"
)

const (
	// EnvFileName is the name of the generated env file
	EnvFileName = ".env.development.local"

	// DefaultDomain is the default space.local domain
	DefaultDomain = "space.local"

	// EnvFileHeader is the header comment for generated env files
	EnvFileHeader = "# Generated by space-cli for local development with space.local DNS\n# Do not commit this file to version control\n"
)

// EnvGenerator generates .env.development.local files for Vite projects
type EnvGenerator struct {
	workDir string
	hash    string
	domain  string
}

// ServiceEnvConfig defines environment variables for a service
type ServiceEnvConfig struct {
	ServiceName string
	Port        int
	EnvVarName  string // e.g., "VITE_API_BASE_URL"
}

// EnvGeneratorResult contains the result of env file generation
type EnvGeneratorResult struct {
	FilePath   string
	Generated  bool
	Variables  map[string]string
	BackedUp   bool
	BackupPath string
}

// NewEnvGenerator creates a new environment file generator
func NewEnvGenerator(workDir string) (*EnvGenerator, error) {
	absWorkDir, err := filepath.Abs(workDir)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve work directory: %w", err)
	}

	hash := dns.GenerateDirectoryHash(absWorkDir)

	return &EnvGenerator{
		workDir: absWorkDir,
		hash:    hash,
		domain:  DefaultDomain,
	}, nil
}

// NewEnvGeneratorWithHash creates a generator with a specific hash
func NewEnvGeneratorWithHash(workDir, hash string) (*EnvGenerator, error) {
	absWorkDir, err := filepath.Abs(workDir)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve work directory: %w", err)
	}

	return &EnvGenerator{
		workDir: absWorkDir,
		hash:    hash,
		domain:  DefaultDomain,
	}, nil
}

// SetDomain sets a custom domain (default: space.local)
func (g *EnvGenerator) SetDomain(domain string) {
	g.domain = domain
}

// Generate generates the .env.development.local file based on space-cli config
func (g *EnvGenerator) Generate(cfg *config.Config) (*EnvGeneratorResult, error) {
	result := &EnvGeneratorResult{
		FilePath:  filepath.Join(g.workDir, EnvFileName),
		Variables: make(map[string]string),
	}

	// Build environment variables from services
	for serviceName, svcConfig := range cfg.Services {
		if svcConfig.Port == 0 {
			continue
		}

		// Generate the space.local URL for this service
		url := g.generateServiceURL(serviceName, svcConfig.Port)

		// Map common service names to Vite environment variables
		envVars := g.mapServiceToEnvVars(serviceName, url)
		for k, v := range envVars {
			result.Variables[k] = v
		}
	}

	// If no variables to write, skip generation
	if len(result.Variables) == 0 {
		return result, nil
	}

	// Backup existing file if present
	if _, err := os.Stat(result.FilePath); err == nil {
		backupPath := result.FilePath + ".backup"
		if err := g.copyFile(result.FilePath, backupPath); err == nil {
			result.BackedUp = true
			result.BackupPath = backupPath
		}
	}

	// Generate the env file content
	content := g.generateContent(result.Variables)

	// Write the file
	if err := os.WriteFile(result.FilePath, []byte(content), 0644); err != nil {
		return nil, fmt.Errorf("failed to write env file: %w", err)
	}

	result.Generated = true
	return result, nil
}

// GenerateWithServices generates env file with explicit service configurations
func (g *EnvGenerator) GenerateWithServices(services []ServiceEnvConfig) (*EnvGeneratorResult, error) {
	result := &EnvGeneratorResult{
		FilePath:  filepath.Join(g.workDir, EnvFileName),
		Variables: make(map[string]string),
	}

	for _, svc := range services {
		url := g.generateServiceURL(svc.ServiceName, svc.Port)
		if svc.EnvVarName != "" {
			result.Variables[svc.EnvVarName] = url
		} else {
			// Auto-generate env var name
			envVars := g.mapServiceToEnvVars(svc.ServiceName, url)
			for k, v := range envVars {
				result.Variables[k] = v
			}
		}
	}

	if len(result.Variables) == 0 {
		return result, nil
	}

	// Backup existing file if present
	if _, err := os.Stat(result.FilePath); err == nil {
		backupPath := result.FilePath + ".backup"
		if err := g.copyFile(result.FilePath, backupPath); err == nil {
			result.BackedUp = true
			result.BackupPath = backupPath
		}
	}

	content := g.generateContent(result.Variables)

	if err := os.WriteFile(result.FilePath, []byte(content), 0644); err != nil {
		return nil, fmt.Errorf("failed to write env file: %w", err)
	}

	result.Generated = true
	return result, nil
}

// MergeWithExisting merges new variables with existing env file
func (g *EnvGenerator) MergeWithExisting(newVars map[string]string) (*EnvGeneratorResult, error) {
	result := &EnvGeneratorResult{
		FilePath:  filepath.Join(g.workDir, EnvFileName),
		Variables: make(map[string]string),
	}

	// Read existing variables
	existingVars, err := g.readExistingEnv(result.FilePath)
	if err != nil && !os.IsNotExist(err) {
		return nil, fmt.Errorf("failed to read existing env file: %w", err)
	}

	// Merge: new variables override existing
	for k, v := range existingVars {
		result.Variables[k] = v
	}
	for k, v := range newVars {
		result.Variables[k] = v
	}

	// Backup existing file if present
	if _, err := os.Stat(result.FilePath); err == nil {
		backupPath := result.FilePath + ".backup"
		if err := g.copyFile(result.FilePath, backupPath); err == nil {
			result.BackedUp = true
			result.BackupPath = backupPath
		}
	}

	content := g.generateContent(result.Variables)

	if err := os.WriteFile(result.FilePath, []byte(content), 0644); err != nil {
		return nil, fmt.Errorf("failed to write env file: %w", err)
	}

	result.Generated = true
	return result, nil
}

// generateServiceURL creates a space.local URL for a service
func (g *EnvGenerator) generateServiceURL(serviceName string, port int) string {
	// Format: http://{serviceName}-{hash}.space.local:{port}
	hostname := fmt.Sprintf("%s-%s.%s", serviceName, g.hash, g.domain)
	return fmt.Sprintf("http://%s:%d", hostname, port)
}

// mapServiceToEnvVars maps service names to Vite environment variable names
func (g *EnvGenerator) mapServiceToEnvVars(serviceName, url string) map[string]string {
	vars := make(map[string]string)

	// Normalize service name
	normalized := strings.ToLower(serviceName)
	normalized = strings.ReplaceAll(normalized, "-", "_")

	// Common patterns for API services
	switch {
	case strings.Contains(normalized, "api"):
		vars["VITE_API_BASE_URL"] = url
		vars["VITE_API_URL"] = url
	case normalized == "app" || normalized == "frontend" || normalized == "web":
		vars["VITE_APP_BASE_URL"] = url
		vars["VITE_APP_URL"] = url
	case strings.Contains(normalized, "auth"):
		vars["VITE_AUTH_URL"] = url
	case strings.Contains(normalized, "ws") || strings.Contains(normalized, "websocket"):
		// Convert http to ws for websocket services
		wsURL := strings.Replace(url, "http://", "ws://", 1)
		vars["VITE_WS_URL"] = wsURL
	default:
		// Generic pattern: VITE_{SERVICE_NAME}_URL
		envName := fmt.Sprintf("VITE_%s_URL", strings.ToUpper(normalized))
		vars[envName] = url
	}

	return vars
}

// generateContent creates the env file content
func (g *EnvGenerator) generateContent(vars map[string]string) string {
	var sb strings.Builder
	sb.WriteString(EnvFileHeader)
	sb.WriteString("\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(vars))
	for k := range vars {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("%s=%s\n", key, vars[key]))
	}

	return sb.String()
}

// readExistingEnv reads existing environment variables from a file
func (g *EnvGenerator) readExistingEnv(filePath string) (map[string]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	vars := make(map[string]string)
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse KEY=VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			// Remove quotes if present
			value = strings.Trim(value, `"'`)
			vars[key] = value
		}
	}

	return vars, scanner.Err()
}

// copyFile copies a file from src to dst
func (g *EnvGenerator) copyFile(src, dst string) error {
	data, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	return os.WriteFile(dst, data, 0644)
}

// Hash returns the directory hash
func (g *EnvGenerator) Hash() string {
	return g.hash
}

// WorkDir returns the working directory
func (g *EnvGenerator) WorkDir() string {
	return g.workDir
}
